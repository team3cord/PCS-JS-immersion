The more JavaScript there is in your codebase, the more your global scope may get “polluted” with numerous functions and variables that would actually be better kept private to whatever set of code uses it. With this comes the risk of name collision, with one script unintentionally overwriting another’s identifiers. This leads to bugs.
We need to be able to create self-contained, opaque batches of JavaScript code, which would expose only selected identifiers, if any, to the outside world. Indeed, this is a major requirement for “programming in the large,” being able to bring in frameworks and libraries in any page without risking a clash. This is what the module pattern is for.
The whole idea of the module pattern is to create a private scope for var-declared identifiers and functions, a scope that only functions defined inside it can access. To make some of these definitions accessible to the outside world, our enclosing function has two choices. It may return an object with these selected values as properties (see the facing page); we just need to assign that returned object to a variable in the outside scope. Another way is to pass the enclosing function a scope object that it writes properties to (to make these global, you’d simply pass window).
In JavaScript, identifiers first used with the var declaring keyword are local. (They belong to the function currently defined.) Identifiers first used without var are global. (They’re grafted onto the current default scope, which most of the time means the global window object.):wq

